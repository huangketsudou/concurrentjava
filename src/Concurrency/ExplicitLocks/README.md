### 显式锁

在java5之后添加了一种新的机制：ReentrantLock，这作为一种可选的高级工具。

#### Lock与ReentrantLock

Lock接口中定义的一组抽象操作：

```java
public interface Lock{
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    void unlock();
	Condition newCondition();
}
```

Lock提供了一种无条件的，可轮询的，定时的以及可中断的锁获取操作，所有加锁和解锁方法都是显式的，

14章中有newCondition的用法

ReentrantLock实现了Lock接口，并提供了synchronized相同的互斥性和内存可见性。且可以实现可重入锁。

内置锁无法中断一个正在等待获得锁的线程，或者无法在请求一个锁时无限地等待。

Lock接口实现的锁必须在finally中释放锁，否则如果该代码在try语句块中抛出异常，该锁就无法释放了。

```java
Lock lock = new ReentrantLock();
lock.lock();
try{
//
}catch (Exception e){
//
}finally{
	lock.unlock();
}

```

#### 轮询锁和定时锁

可定时的与可轮询的锁获取模式，由tryLock方法实现，该方法可用于防止死锁的产生，tryLock会尝试获取多个锁，如果并能同时获得，那么会进行回退并重新尝试，但是休眠时间中需要包括固定部分以及随机部分，防止活锁的发生。

#### 可中断的锁获取操作

可终端的锁获取操作同样能在可取消的操作中使用加锁，lockInterruptibly方法能够在获得锁的同时保持对中断的响应。

#### 性能考虑因素

#### 公平性

ReentrantLock的构造函数提供两种公平性选择，创建一个非公平锁或者一个公平锁。实现ReentrantReadWriteLock

#### 读写锁

```java
public interface ReadWriteLock{
    Lock readLock();
    Lock writeLock();
}
```

在java中有读写锁的接口，其中只有两个方法，一个返回读锁，一个返回写锁。允许多个读操作，只允许一个写操作。读写锁的实现方式：

**释放优先**：一个写入操作释放锁之后，队列里同时有写入操作和读取操作，先执行什么操作的

**读线程插队**：锁由都进程持有，但有写进程等待，此时有新的都进程到达，那么读进程能否插队到写进程之前，如果允许，并发效率高，但是写进程可能发生饥饿问题。

**重入性**：读取锁和写入锁能否重入

**降级**：一个线程持有写入锁，那么其是否可以在不释放该锁时获得读取锁。

**升级**：一个线程持有读取锁，那么其是否可以在不释放该锁时获得写入锁。当有两个读线程同时升级，两个都不会释放读取锁，导致死锁。

采用这个锁来包装Map实现和ConcurrentHashMap差不多的效果。





### java锁的类型

#### 常见的锁

 Synchronized，它就是一个：非公平，悲观，独享，互斥，可重入的重量级锁 

ReentrantLock，它是一个：默认非公平但可实现公平的，悲观，独享，互斥，可重入，重量级锁。

ReentrantReadWriteLocK，它是一个，默认非公平但可实现公平的，悲观，写独享，读共享，读写，可重入，重量级锁。

#### 按照性质分

##### **公平锁/非公平锁**

 公平锁是指多个线程按照申请锁的顺序来获取锁。非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。 非公平锁的优点在于吞吐量比公平锁大。 

##### **乐观锁/悲观锁**

 乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。悲观锁在Java中的使用，就是利用各种锁。乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。 

**注意在interviews中有关于CAS的实现**

##### **独享锁/共享锁**

 独享锁是指该锁一次只能被一个线程所持有。共享锁是指该锁可被多个线程所持有。对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReentrantReadWriteLock，其读锁是共享锁，其写锁是独享锁。 

##### **互斥锁/读写锁**

 上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。互斥锁在Java中的具体实现就是ReentrantLock，读写锁在Java中的具体实现就是ReentrantReadWriteLock 

##### **可重入锁**

 可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。 递归或者子类调父类的同步方法。

#### **按照设计方案来分类**

##### **自旋锁/自适应自旋锁**

 在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。 

##### **锁粗化/锁消除**

 锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。 

##### **偏向锁/轻量级锁/重量级锁**

 这三种锁是指锁的状态，并且是针对Synchronized。 

##### **分段锁**

 分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。 