### 取消和关闭

线程提供了中断作为一种协作机制，能使一个线程终止另一个线程的当前工作。

#### 任务取消

如果某个代码能在某个操作正常完成之前将其置入“完成”状态，那么该操作可以取消

取消操作的原因

1. 用户请求取消
2. 有时间限制的操作
3. 应用程序事件
4. 错误
5. 关闭

协作机制同构设置某个已请求取消标记来时，通过定时检查该标记，当标记为取消时，就取消任务。

##### 中断

上面的简单协作机制，在多线程环境下有重大的隐患，当标记为取消时，如果原线程在执行的任务处于阻塞状态，此时就无法正常退出了。文件[BrokenPrimeProducer.java](../../../src/main/java/com/jiedong/cancellationandshutdown/BrokenPrimeProducer.java)  展示了该情况。

每个线程都有一个boolean类型的中断。当中断线程时，该标识被置为true。iterrupt能中断目标线程。isInterrupted能返回中断状态。interrupted方法会重置中断的状态，调用了中断方法将设置其中断状态。然后根据被取消的操作来检查中断状态。

注意：调用interrupt并不意味着立即停止目标线程的工作，而是传递了请求中断的消息。最终中断线程的是线程自己。

##### 中断策略

中断策略规定线程解释某个中断请求，中断必须处理InterruptedException异常

##### 响应中断

有两种策略能够处理上面的异常：

1. 传递异常：使自己的方法也可以成为可中断的阻塞方法
2. 恢复中断状态：使调用栈中的上层代码能够对其进行处理

如果不能或者不想传递InterruptedException（Runnable定义的任务），不允许在try~catch块中不处理异常，直接屏蔽。

##### 通过future来实现取消

Executor.submit通过返回一个future来描述任务，其拥有一个cancel方法，其带有一个boolean参数，表示取消操作是否成功，如该参数为true并且任务正在运行，那么该线程能够被中断，如果这个参数为false，那么意味着不要中断线程。

##### 处理不可阻塞的中断

java中许多可阻塞的方法都是通过提前返回或者抛出InterruptedException来响应中断请求。但是并不是所有的可阻塞方法或者阻塞机制都能响应中断，

线程阻塞的原因：

java.io中的同步socketI/O

java.io中的同步I/O。

seletor的异步I/O

获得锁

##### 采用newTaskFor封闭非标准的取消

采用newTaskFor封闭

#### 停止基于线程的服务

应用程序通常会创建拥有多个线程的服务，应用程序结束时，服务所拥有的线程也需要结束。正确的封装原则是，除非拥有该线程，否则不允许对线程进行操作。

线程的所有权不可传递，线程的所有者为服务，服务应当提供自己的生命周期方法来关闭持有的线程。

##### 关闭ExecutorService

使用类的shutdown方法

##### 毒丸对象

得到一个毒丸对象时，立刻停止线程。必须明确生产者和消费者数量

##### shutdownNow

取消正在执行的任务，并返回所有已提交但是未开始的任务，

#### 处理非正常的线程终止

导致线程提前死亡的最主要原因是runtimexception,该异常会直接在控制台输出信息。

##### 未捕获的异常

#### JVM关闭

1. 最后一个非守护线程结束
2. 调用了System.exit
3. 其他特定于平台的关闭方法

##### 关闭钩子

关闭钩子指的是通过Runtime.addShutdownHook注册单位开始的线程。

##### 守护线程

需要一些线程来执行辅助工作，但是不阻碍JVM的关闭。JVM启动时创建的所有线程，除主线程外都是守护线程。当创建一个新线程时，新线程会继承创建它的线程的状态。主线程创建的所有线程都是普通线程。

当一个线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM会正常退出。当JVM停止时，所有存在的守护线程被抛弃，即不会执行finally模块。

当不再需要资源时，可以交给垃圾回收器回收，但套接字句柄或者文件句柄，就需要显式地交回系统。