### 线程池的使用

在实际应用程序中使用任务执行框架出现的一些与服务声明周期相关的细节问题，并给出一些对线程池进行配置和调优的高级选项以及高级实例。

#### 执行与策略之间的隐形耦合

executor使用了中介者模式以及命令模式？存疑

executor可以把任务的提交与任务的执行策略解耦开来，但是部分任务需要显式地指定执行策略。

1. 依赖性任务：如果线程池中的任务依赖其他任务，会对线程池的执行策略产生活跃性问题
2. 使用线程封闭机制的任务：此时，excutor变成一个单线程的池，可以保证任务的顺序执行，有newsinglethreadexecutor方法返回实例
3. 对相应时间敏感的任务：
4. 使用threadLocal的任务：使用threadlocal可以使每个线程都可以拥有某个变量的一个私有版本。只有先后曾本地值的生命周期受限于任务的生命周期时，该模块才有意义。有关threadlocal可以看这篇博客——[Java进阶（七）正确理解Thread Local的原理与适用场景]( http://www.jasongj.com/java/threadlocal/ ) 应用场景
   1. 每个线程需要有自己的单独的实例
   2. 实例需要再多个方法中共享，但不希望被多线程共享
   3. 实现原理为：每一个线程会维护一个map，该map的键位threadlocal对象，值为threadlocal的存储的值，map中的entry对于每个键都是一个弱引用——关于强弱引用[理解Java的强引用、软引用、弱引用和虚引用]( https://juejin.im/post/5b82c02df265da436152f5ad )
5. 只有线程池中任务都是同类型而且互相独立时，线程池的性能才能达到最大。任务执行时间长的与短的混在一起，容易造成拥塞。

##### 线程饥饿死锁

线程池中，任务依赖其他任务，会产生死锁。一个任务提交另一个任务到同一个线程池（假设该线程池为单线程的），且依赖于这个被提交的任务，那么第一个任务就无法完成。只要线程池中的任务需要无限期地等待一些必须由池中其他任务才能提供的资源或条件，就会发生线程饥饿死锁。

##### 运行时间较长的任务

任务阻塞的时间过长，响应性会变得糟糕，可通过限制执行等待资源的时间来实现提高响应性，对于大多数的类方法，如Thread.join,BlockingQueue.put,Seletctor.select等都有限时版本和非限时版本。如果线程等待超时，可把任务标记为失败，重新放回队列，并等待再次执行。

#### 设置线程池大小

n为处理器数量，U为cpu利用率，w/c为线程池的等待时间比计算时间，N=n*U*（1+W/C）

#### 配置ThreadPoolExecutor

参考Executors的源代码并同构构造函数来实现满足要求的自定义线程池。

##### 线程池的创建与销毁

基本大小，最大数量，等待时间是其基本属性。

##### 管理队列任务

对于固定大小的线程池，当请求超过了线程池的处理能力，任务将在runnable队列中等待，但是如果任务过多，也将耗尽资源。

可以使用有界队列来管理等待的任务。例如LinkedNLockingQueue,可以避免资源耗尽

对于非常大的线程池，可以使用synchronousQueue来避免任务排队，这个不是一个真正的队列，而是线程之间任务移交的机制，要求线程必须是可拒绝的，或者线程池是无界的。

##### 饱和策略

通过setRejectedExecutionHandler来调整饱和策略。JDK已经提供了几种饱和策略的实现。

1. 中止（abortPolicy）：该方法抛出一个异常，由调用者捕获，并处理
2. 抛弃（discard）：该策略直接抛弃新的任务
3. discard-oldest：抛弃最早提交而又无法执行的任务，不能与优先级任务一起用
4. caller-runs：将某些任务回退到调用者，在主线程中执行任务，此时主线程不能再提交新的任务

使用信号量机制也可以实现

##### 线程工厂

线程池需要创建一个线程时需要通过线程工厂方法，默认的方法创建新的非守护线程。

##### 在调用构造函数之后再定制ThreadPoolExecutor

再调用完线程池ThreadPoolExecutor后还是可以用setter函数来改变线程池的基本参数。setter函数要参考源码

#### 拓展ThreadPoolExecutor

ThreadPoolExecutor提供了几个可以再子类中修改的方法，可以扩展其行为。

#### 递归算法并行化

对于迭代的过程要求各任务之间是不互相干预的，也可以将串行递归变成并行的递归，使用多线程的方式。

