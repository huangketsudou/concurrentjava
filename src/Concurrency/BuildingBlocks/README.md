### 基础构建模块

介绍java库中一些能满足线程安全的容器类以及用于协调多个相互协作的线程控制流的同步工具类。

[Java并发——同步容器与并发容器](https://www.cnblogs.com/shijiaqi1066/p/3412275.html)

#### 同步容器类

同步容器类包括Vector和Hashtable，这些同步的封装器类是由Collections.synchronizedXxx等工厂方法创建的。这部分包含在早期的jdk当中，但是这些类有较大的缺陷——单个方法被使用时可以保证线程安全，但是复合操作就需要额外的客户端加锁来实现。

##### 同步容器类的问题

同步容器类是线程安全的，但也可能需要额外的措施来保障复合操作的线程安全，如：迭代，跳转以及条件运算，这些操作在没有客户端枷锁的情况下任然是线程安全的，而当其他线程并发地修改容器时，就会导致错误。例如

```java
public static Object getLast(vector list){
    int lastIndex = list.size()-1;
    return list.get(lastIndex);
}
public static void deleteLast(vector list){
    int lastIndex = list.size()-1;
    list.remove(lastIndex);
}
```

如上vector是线程安全的，确实没有线程能够同时访问list的remove和get方法，但是有一种情况是getLast和deleteLast在两个线程中执行，当两者都读出lastIndex之后，在执行remove完成之后，get执行，此时lastIndex已经被删除了，因此getLast抛出异常，但我们不希望这种结果。除非，整个list一开始就是空的。因此需要在客户端上加锁

```java
public static Object getLast(vector list){
    synchronized(this) {int lastIndex = list.size()-1;
    return list.get(lastIndex);}
}
public static void deleteLast(vector list){
    synchronized(this){int lastIndex = list.size()-1;
    list.remove(lastIndex);}
}
```

通过上述的加锁保证在调用size和get时不会发生变化，确保原子性。

##### 迭代器与ConcurrentModificationException

在迭代器迭代过程中，如果有线程并发地修改容器，就可能导致错误，因此需要在使用迭代器时对容器加锁。为了解决这个问题，java采用了及时失败机制，就是只要发现在迭代过程中修改容器，就立刻抛出异常，但是直接对容器添加锁会导致性能降低。解决办法是，在迭代时复制一个容器的副本，这样就没有其他的线程会修改复制的容器了。

##### 隐藏迭代器

对于迭代器进行操作时，可能存在有一些隐藏的迭代器，这部分迭代器可能会导致异常。例如一些容器类的toString方法，就是通过调用迭代器实现的。

#### 并发容器

并发容器是针对多个线程并发访问设计的，包括ConcurrentHashMap和CopyOnWriteArrrayList,BlockingQueue，ConcurrentSkipListMap和ConcurrentSkipListSet等。

##### ConcurrentHashMap

该容器并不是将每个方法都在同一个锁上同步导致每次只有一个线程能够访问容器，而是采用了分段锁的方式(可以参考第11章的内容)，在该机制中可以实现任意数量的读进程可以并发地访问Map，执行读进程以及写进程可以并发地访问Map，一定数量的写入进程可以并发地修改Map，最终对于但线程环境下的性能影响很小。

该容器进行迭代时不会抛出异常，所以不需要加锁，因为该迭代器具有弱一致性，可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并在迭代器被修改之后，将修改操作放映给容器。

对若这部分容器的妥协：size，isempty等反映容器整体情况的方法只能返回一个估计值，但实际上在并发的过程中，size等方法实际没有什么实际意义，因为一直在变。

##### 额外的原子Map操作

如果需要在map中使用原子操作，考虑使用ConcurrentMap

##### CopyOnWriteArrayList

只要正确发布一个事实不可变对象，那么在访问该对象的时候就不再需要进一步的同步，每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。而多个线程之间的迭代器之间不会互相干扰，因为在构建迭代器的时候就拷贝了一份副本，该类适合于读多写少的进程。
有关CopyOnWriteArrayList可以参考这篇博客[CopyOnWriteArrayList原理解析](https://blog.csdn.net/reachwang/article/details/91909070) ,的源代码，实际上是因为在修改的过程中，使用了一个副本。所以即使在迭代器的生命周期中对容器内容进行了修改，也不会改变迭代器创建时的元素。

#### 阻塞队列和生产者-消费者模式

阻塞队列提供了可阻塞的put和take方法，以及支持定时的offer和poll方法，如果队列满了，那么put方法将阻塞直到有空间可用，如果队列为空，那么take方法将会阻塞，队列可以有界也可以无界。基于阻塞队列可以实现生产者—消费者模式，并简化实现的过程。

BlockingQueue具有多种的实现形式，包括LinkedBlockingQueue和ArrayBlockingQueue时FIFO队列，两者分别于LinkedList和ArrayList类似，实现相似的性能，而PriorityBlockingQueue则是一个按优先级排序的队列，实现自定义的排序。最后还包括SynchronousQueue，这个并不是一个真正的队列，因为器不为队列中的元素维持储存空间，而是维护一组线程，这些线程在等待把元素加入或者移出队列，源代码中是采用队列或者栈在执行。

##### 串行线程封闭

对于生产者-消费者模型，其通过阻塞队列，促进了串行线程封闭，从而将对象所有权从生产者交付给消费者，线程封闭对象只能由单个线程拥有，因此对象被封闭在单一的线程中，拥有它的线程可以任意更改对象，因为独占访问权。

##### 双端队列以及工作密取

java中还有一种同步队列——BlockingDeque，实现阻塞的双端队列，其具体的实现为LinkedBlockingDeque，阻塞双端队列适用于工作密取模式(working steal)

在工作密取的模式中，每个消费者都有一个属于自己的双端队列，如果一个消费者完成了自己的队列中的全部内容，那么该消费者还可以从其他消费者的队列中取工作。正常情况下从双端队列的对头取数据，如果需要从其他队列取数据，那么会从队列的末尾取数据，减少冲突发生的频率。该模式适用于既是生产者又是消费者的问题。例如爬虫网页处理程序，一个处理过的网页会发现更多待处理的网页。可以将这些待处理的网页放到队列末，供其他线程取用，从而保证每个线程都处于忙碌状态。

#### 阻塞方法与中断方法

线程阻塞的原因：等待I/O操作结束，等待获得一个锁，等待从Thread.sleep方法中醒来，或者等待另一个线程的计算结果.

线程阻塞状态：Blocked，waiting或者timed_waiting。

Thread提供interrupt方法，用于中断线程或者查询线程是否已经中断。每个线程都有一个布尔类型的属性，表示线程的中断状态，当中断线程时，将会设置该标志位。中断是一种协作机制，一个线程不能要求其他线程停止正在执行的操作而执行其他操作，当线程A中断B时，A仅要求B在某个可以暂停的地方停止正在执行的操作，前提是线程B可以停下来。关于中断可以参考博文——[架构进化论](https://www.cnblogs.com/binyue/) 和[Java 线程阻塞、中断及优雅退出]( https://blog.csdn.net/chengmaoning/article/details/73129285 )

当代码中调用一个抛出异常的方法时，自己的方法就变成了一个阻塞方法，必须处理异常，处理异常的方式有两种：1、传递异常，2恢复中断。

#### 同步工具类

同步工具类可以是任意的对象，只要它根据自身的状态来协调线程的控制流，阻塞队列可以用作同步工具类，其他类型的同步工具类包括信号量，栅栏以及闭锁。

##### 闭锁

可以延迟线程的进度直到其到达终止状态。

CountDownLatch是一种灵活的闭锁实现形式，可以用作闭锁的形式，可以使一个或多个线程等待一组事件发生。闭锁事件包含一个计数器，表示等待的事件数量，并利用countdown递减计数器，表示一个事件发生了。await方法则等待计数器达到0，表示事件已全部发生。只要计数器的值为非零，await会一直阻塞。详情见文件[TestHarness.java](../../../src/main/java/com/jiedong/BuildingBlocks/TestHarness.java)

##### Future Task

future task表示的计算通过Callable来实现，相当于一种可生成结果的Runnable，并处于三中状态waiting to run，running和Completed。future.get的行为取决于任务的状态。Callable表示的任务可以抛出受检查的或者未受检查的异常。

##### 信号量

计数信号量(semaphore)用来控制同时访问的某个特定资源的操作数量。计数信号量还可以实现某种资源池，或者对容器施加边界。信号量管理着一组虚拟的许可，许可的初始数量可以通过构造函数来指定，在执行操作时可以首先获得许可，并在使用以后释放许可。如果没有许可，acquire请求将会阻塞。release方法将返回一个许可给信号量。使用信号量可以实现将任何一种容器变成有界阻塞容器。

##### 栅栏

类似于闭锁，可以阻塞一组线程直到某个事件发生，栅栏与闭锁的关键区别在于，所有的线程必须同时**到达**栅栏位置，才能继续执行。闭锁用于等待事件，栅栏用于等待其他线程。

CyclicBarrier可以使一定的参与方反复地在栅栏位置汇集。适用于并行迭代算法，这种算法通常将一个问题拆分为一系列的独立子问题，当线程到达栅栏位置时将调用await方法，这个方法将会阻塞所有线程，直到所有线程都到达栅栏位置。此时释放线程，并重置栅栏。如果对await调用超时，或者await阻塞的线程中断，那么栅栏被认为被打破了。await将会为每个线程返回一个唯一的到达索引号，可以用于选举一个领导线程，用以执行一些特殊工作，还可以将一个栅栏操作传递给构造函数。

#### 构建高效且可伸缩的结果缓存

对于复杂的计算任务需要使用结果缓存来实现重用计算结果。

### 概念与规则

1. 可变状态：所有的并发问题都可以归结为如何协调对并发状态的访问。可变状态越少，就越容易确保线程安全
2. 尽量将域声明为final类型，除非需要他们是可变的
3. 不可变对象一定是线程安全的：不可变对象能降低并发编程的复杂性，他们更为简单和安全，可以任意共享而无需使用加锁或保护性复制等机制
4. 封装有助于管理复杂性：在编写线程安全的程序时，即使可以将所有数据都保存在全局变量中，也要尽量iang数据封装在对象中，这样更易于维持不变性条件：将同步机制封装在对象中，易于遵循同步策略
5. 用锁来保护每个可变变量
6. 当保护同一个不变性条件中的所有变量时，要使用同一个锁
7. 在执行复合操作时，要持有锁
8. 如果从多个线程中访问同一个可变变量时没有同步机制，那么程序会出现问题
9. 不要故作聪明地推断出不需要使用同步
10. 在设计过程中考虑线程安全，或者在文档中明确地指出它不是线程安全
11. 将同步策略文档化

