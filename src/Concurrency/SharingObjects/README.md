### 共享对象
有关java编程模型的重要文章，在看这一章先看这个[Java并发编程：volatile关键字解析](https://www.cnblogs.com/dolphin0520/p/3920373.html)，注意看评论区210楼的评论，有关inc的问题，原文章的结果是错的。

同步代码块和同步方法可以确保以原子的方式执行操作，但是同步还有一个重要的方面——内存可见性，该性质确保一个线程修改了对象状态之后，还需要其他的线程可以看到发生的状态变化。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。
并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。
#### 可见性

编译器、处理器以及运行时可能对操作的执行顺序进行重排序，导致可见性问题，例如文件[NoVisibility.java](../../../src/main/java/com/jiedong/SharingObjects/NoVisibility.java)，最终的输出结果可能是0，甚至一直不输出值。

##### 失效数据

当线程查看变量时，可能得到一个已经失效的值，且对于多个变量，可能不会同时出现失效值。

##### 非原子的64为操作

线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而非随机值，这称之为最低安全性。但是对于非volatile的long或者double这样的64为数据类型，由于JVM允许将其变为两个32位的值进行读写，因此如果两个线程分别对其进行读写，那么有可能输出一个值的高32位和另一个值得低32位。

##### 加锁和可见性

内置锁可以用于确保某个线程以一种可预见的方式来查看另一个线程的执行结果。访问某个共享可变的变量时，要求所有线程在同一个锁上同步，以确保某个线程写入的变量值对其他线程而言是可见的。

##### volatile变量

java语言提供一种较弱的机制，用来确保将变量的更新操作通知到其他线程。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。

把变量声明为volatile之后，该变量是共享的，因此不会将该变量的操作与其他内存操作一起进行重排序，volatile变量不会被缓存到寄存器或者对其他处理器不可见的地方。但是访问volatile变量不会执行加锁机制，因此不会执行线程阻塞。

从内存可见性来看，写入volatile变量相当于退出同步代码块，读取volatile变量相当于进入同步代码块。

volatile变量的局限性：该变量通常用作某个操作完成，分发中断或者状态的标识。但是该变量不能保证某些操作的原子性，例如count++，除非能确保只有一个线程对变量执行写操作。因此volatile只能确保可见性(线程对某一个变量多次读取保证有效)。

volatile 保证内存可见性，不保证原子性和有序性。

在以下条件下可以使用volatile变量：

1. 对变量的写入不依赖变量的当前值，或者能够确保仅有单个线程更新变量的值
2. 该变量不会与其他状态变量一起纳入不变性条件
3. 在访问变量是不需要加锁。

```java
volatile boolean asleep;
while (!asleep){
    dosomething();
}
```

#### 发布与逸出

发布：使对象能够在当前作用域之外的代码中使用

逸出：不该发布的对象被发布时称之为逸出

在许多情况下，要确保对象及其内部状态不被发布，而在某些情况下需要发布该对象，如果在发布的时候保证线程安全性，那么就需要同步。发布内部状态可能会破坏封装性，是程序难以维持不变性。

发布一个对象的时候可能会顺带发布其他的对象，例如发布一个引用对象，或者一个引用数组，特别是在发布私有的对象时，如果对象是一个引用对象，那么在作用域外就可以对这个私有对象进行修改，导致错误。见[UnsafeStates.java](../../../src/main/java/com/jiedong/SharingObjects/UnsafeStates.java)

##### 安全的对象构建过程

不安全的方式：——[Java并发编程——this引用逸出("this"Escape)]( https://blog.csdn.net/flysqrlboy/article/details/10607295 )

1. this指针通过构造函数逸出，
2. 在构造函数中启动一个线程，当对象在其构造函数中创建一个线程时，无论显式创建还是隐式创建，this指针都会被新创建的线程共享。此时最好不要立刻启动，
3. 在构造函数中调用一个可改写的实例方法时，(非私有方法或者final方法)，同样会导致this引用在构造过程中逸出
4. 只有构造函数返回时，this指针才应该从线程中引出

#### 线程封闭

如果仅在单线程内访问数据，就不需要进行同步，也是最简单的同步方式。例如Swing以及JDBC的Connection中都大量使用了线程封闭计数。

##### ad-hoc线程封闭

指维护线程封闭的职责完全由程序实现来承担，应用场景为：将某个系统的子系统设计为一个单线程子系统。

##### 栈封闭

栈封闭只有通过局部变量才能访问对象，局部变量的固有属性为封闭在执行线程当中，其他线程无法访问这个栈。java中的基本数据类型就是使用到了栈封闭的方法，

##### ThreadLocal类

这个类能够使线程中的某个值与保存值的对象相关联起来，并提供get和set等方法或者接口，这些方法为每个使用该变量的线程存有一个独立副本，因此get可以返回由当前执行线程在调用set时设置的最新值。ThreadLocal对象通常用于防止可变的单实例变量或全局变量进行共享。

#### 3.4不变性

满足同步需求的另一种方法是使用不可变对象——**不可变对象一定是线程安全的**

1. 对象创建后其状态不可以改变
2. 对象的所有域都是final类型
3. 对象是正确创建的，在构造函数中，this引用没有逸出

##### final域

限制对象的可变性也就相当于限制了该对象可能的状态集合，

#### 安全发布

##### 不正确发布

对于代码清单3-15[Holder.java](../../../src/main/java/com/jiedong/SharingObjects/Holder.java)的代码看这个博客[java并发编程实践 3.5 安全发布]( [https://yfsyfs.gitee.io/2019/07/08/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5-3-5-%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83/](https://yfsyfs.gitee.io/2019/07/08/java并发编程实践-3-5-安全发布/) )，会导致抛出异常的原因在于，`n!=n`这句话需要读取两次n的值，当读取第一次n的之后进程由于某些原因中断，而此时由于holder对象不是安全同步的，会导致另外的线程又修改了holder的引用，导致原本中断的线程启动去读n的时候读到了新的n值。

##### 不可变对象与初始化安全

即使某个对象的引用对其他线程是可见的，也并不意味着对象状态对于使用该对象的线程来说一定是可见的。在没有额外同步的情况下，可以安全地访问final类型的域，但是如果final的域所指向的是可变对象，那么在访问这些域锁指向的对象的状态时仍需要同步。安全发布的方式：

1. 在静态初始化函数中初始化一个对象引用
2. 将对象的引用保存到volatile类型的域或者atomicreference对象中
3. 将对象的引用保存到某个正确构造对象的final类型域中
4. 将对象的引用保存到一个由锁保护的域中

可以使用的容器类：Hashtable，synchronizedMap，ConcurrentMap。。。。

##### 事实不可变对象

如果对象在发布后不会被改变，那么其余的线程可以在没有额外同步的情况下进行安全访问，如果对象在实现上是可变的，但是实际上是不会变的，就称该对象为事实不可变对象。

##### 可变对象

如果对象在构造完成之后可以修改，那么安全发布只能保证发布当时的状态可见性，对于可变对象，不仅在发布时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续修改操作的可见性。

对象的发布需求取决于他的可变性：

1. 不可变对象可以通过任意机制来发布
2. 事实不可变对象必须通过安全的方式来发布
3. 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来的

